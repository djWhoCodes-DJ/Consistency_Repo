GFG

Node *compute(Node *head)    {
        vector<int> v,v1;
        while(head){
              v.push_back(head->data);   
              head=head->next;
        }
        for(int i=0;i<v.size()-1;i++){
            int s=0;
            for(int j=i+1;j<v.size();j++){
                if(v[j]>v[i]) {s=1;break;}
            }
            if(s==0) v1.push_back(v[i]);
        }
        v1.push_back(v[v.size()-1]);
        Node* l1=new Node(v1[0]);
        Node* ans=l1;
        for(int i=1;i<v1.size();i++){
            Node* next=new Node(v1[i]);
            l1->next=next;
            l1=l1->next;
        }
        return ans;
    }



_________________________________________________________


Leetcode

class Solution:
    def bestClosingTime(self, customers: str) -> int:
        max_score = score = 0
        best_hour = -1

        for i, c in enumerate(customers):
            score += 1 if c == 'Y' else -1
            if score > max_score:
                max_score, best_hour = score, i
                
        return best_hour + 1


_________________________________________________________


GFG

Node* deleteNode(Node *head,int x)
{
    if(head == NULL)
        return NULL;
    if(x==1){
        return head->next;
    }
   head->next = deleteNode(head->next,x-1);
   return head;
}



_________________________________________________________

Leetcode

class Solution {
public:
    long long minimumReplacement(vector<int>& nums) {
        int n = nums.size();
        int last = nums[n-1];  // Initialize 'last' with the last element
        long long ans = 0;     // Initialize the total operations count

        // Traverse the array in reverse order
        for (int i = n - 2; i >= 0; --i) {
            if (nums[i] > last) {  // If the current element needs replacement
                int t = nums[i] / last;  // Calculate how many times the element needs to be divided
                if (nums[i] % last) t++; // If there's a remainder, increment 't'
                last = nums[i] / t;  // Update 'last' for the next comparison
                ans += t - 1; // Add (t - 1) to 'ans' for the number of operations
            } else {
                last = nums[i]; // Update 'last' without replacement
            }
        }
        return ans; // Return the total number of operations
    }

};


_________________________________________________________

GFG

void getElements(Node* root, vector<int>& inorder, int data){
    if(!root)
        return;
    getElements(root -> left, inorder, data);
    if(data != root -> data)
        inorder.push_back(root -> data);
    getElements(root -> right, inorder, data);
}

Node* getBalancedTree(vector<int> elements, int height){
    if(elements.size() == 0){
        return NULL;
    }
    int mid = elements.size() >> 1;
    Node* temp = new Node(elements[mid]);
    temp -> height = height;
    if(elements.size() == 1){
        
        return temp;
    }
    vector<int> left(elements.begin(), elements.begin() + mid), right(elements.begin() + mid + 1, elements.end());
    temp -> left = getBalancedTree(left, height + 1);
    temp -> right = getBalancedTree(right, height + 1);
    return temp;
    
}

Node* deleteNode(Node* root, int data)
{
    vector<int> inorder;
    getElements(root, inorder, data);
    return getBalancedTree(inorder, 1);
}