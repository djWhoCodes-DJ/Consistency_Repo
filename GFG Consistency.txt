GFG

Node *compute(Node *head)    {
        vector<int> v,v1;
        while(head){
              v.push_back(head->data);   
              head=head->next;
        }
        for(int i=0;i<v.size()-1;i++){
            int s=0;
            for(int j=i+1;j<v.size();j++){
                if(v[j]>v[i]) {s=1;break;}
            }
            if(s==0) v1.push_back(v[i]);
        }
        v1.push_back(v[v.size()-1]);
        Node* l1=new Node(v1[0]);
        Node* ans=l1;
        for(int i=1;i<v1.size();i++){
            Node* next=new Node(v1[i]);
            l1->next=next;
            l1=l1->next;
        }
        return ans;
    }



_________________________________________________________


Leetcode

class Solution:
    def bestClosingTime(self, customers: str) -> int:
        max_score = score = 0
        best_hour = -1

        for i, c in enumerate(customers):
            score += 1 if c == 'Y' else -1
            if score > max_score:
                max_score, best_hour = score, i
                
        return best_hour + 1


_________________________________________________________


GFG

Node* deleteNode(Node *head,int x)
{
    if(head == NULL)
        return NULL;
    if(x==1){
        return head->next;
    }
   head->next = deleteNode(head->next,x-1);
   return head;
}



_________________________________________________________

Leetcode

class Solution {
public:
    long long minimumReplacement(vector<int>& nums) {
        int n = nums.size();
        int last = nums[n-1];  // Initialize 'last' with the last element
        long long ans = 0;     // Initialize the total operations count

        // Traverse the array in reverse order
        for (int i = n - 2; i >= 0; --i) {
            if (nums[i] > last) {  // If the current element needs replacement
                int t = nums[i] / last;  // Calculate how many times the element needs to be divided
                if (nums[i] % last) t++; // If there's a remainder, increment 't'
                last = nums[i] / t;  // Update 'last' for the next comparison
                ans += t - 1; // Add (t - 1) to 'ans' for the number of operations
            } else {
                last = nums[i]; // Update 'last' without replacement
            }
        }
        return ans; // Return the total number of operations
    }

};


_________________________________________________________

GFG

void getElements(Node* root, vector<int>& inorder, int data){
    if(!root)
        return;
    getElements(root -> left, inorder, data);
    if(data != root -> data)
        inorder.push_back(root -> data);
    getElements(root -> right, inorder, data);
}

Node* getBalancedTree(vector<int> elements, int height){
    if(elements.size() == 0){
        return NULL;
    }
    int mid = elements.size() >> 1;
    Node* temp = new Node(elements[mid]);
    temp -> height = height;
    if(elements.size() == 1){
        
        return temp;
    }
    vector<int> left(elements.begin(), elements.begin() + mid), right(elements.begin() + mid + 1, elements.end());
    temp -> left = getBalancedTree(left, height + 1);
    temp -> right = getBalancedTree(right, height + 1);
    return temp;
    
}

Node* deleteNode(Node* root, int data)
{
    vector<int> inorder;
    getElements(root, inorder, data);
    return getBalancedTree(inorder, 1);
}


_________________________________________________________

LEETCODE

class Solution:
    def minTaps(self, n: int, ranges: List[int]) -> int:
        arr = [0] * (n + 1)
        for i, r in enumerate(ranges):
            if r == 0:
                continue
            left = max(0, i - r)
            arr[left] = max(arr[left], i + r)

        end, far_can_reach, cnt = 0, 0, 0
        
        for i, reach in enumerate(arr):
            if i > end:
                if far_can_reach <= end:
                    return -1
                end, cnt = far_can_reach, cnt + 1
            far_can_reach = max(far_can_reach, reach)

        return cnt + (end < n)



_________________________________________________________


GFG 

void printCorner(Node *root)
{

// Base case
if(root==NULL){
    return;
  }
  queue<Node *> q;
  q.push(root);
  while(!q.empty()){
      int count=q.size();
      for(int i=0;i<count ;i++){
          Node *current=q.front();
          q.pop();
          if(i==0 || i==count-1){
              cout<<current->data<<" ";
          }
          if(current->left){
              q.push(current->left);
          }
          if(current->right){
              q.push(current->right);
          }
      }
  }
}



_________________________________________________________

LEETCODE

class Solution {
public:
    vector<int> countBits(int n) {
        vector<int> ans;
		
		// iterating fromt 0 to n
        for(int i = 0; i<=n; i++)
        {
			// sum is initialised as 0
            int sum = 0;
            int num = i;
			// while num not equals zero
            while(num != 0)
            {
				// we have to count 1's in binary representation of i, therefore % 2
                sum += num%2;
                num = num/2;
            }
			// add sum to ans vector
            ans.push_back(sum);
        }
		// return 
        return ans;
    }
};


_________________________________________________________

GFG

class Solution:
    def getCount(self,root,n):
        #code here
        arr=[]
        ans=0
        def inorder(root, level):
            if root.left:
                inorder(root.left,level+1)
            if root.right:
                inorder(root.right,level+1)
            if root.left==None and root.right==None:
                arr.append((root.data, level))
        inorder(root, 1)
        s=len(arr)
        arr.sort(key=lambda x:x[1],reverse=False)
        # print(arr)

        for i in range(s):
            n=n-arr[i][1]
            if n>=0:
                ans+=1

        return ans


_________________________________________________________

Leetcode

class Solution:
    def minExtraChar(self, s: str, dictionary: List[str]) -> int:
        max_val = len(s) + 1
        dp = [max_val] * (len(s) + 1)
        dp[0] = 0 
        dictionary_set = set(dictionary)

        for i in range(1, len(s) + 1):
            dp[i] = dp[i - 1] + 1

            for l in range(1, i + 1): 
                if s[i-l:i] in dictionary_set:
                    dp[i] = min(dp[i], dp[i-l])
                    
        return dp[-1]


_________________________________________________________

Leetcode

class Solution:
    def uniquePaths(self, m: int, n: int) -> int:
        return math.comb(m+n-2, m-1)


_________________________________________________________

GFG

class Solution {
public:
    bool isIsomorphic(Node *root1, Node *root2) {
        // base condition
        if (!root1 && !root2)
            return true;
        
        if ((!root1 && root2) || (root1 && !root2))
            return false;
        
        if (root1->data != root2->data)
            return false;
        
        return (isIsomorphic(root1->left, root2->left) && isIsomorphic(root1->right, root2->right))
            || (isIsomorphic(root1->left, root2->right) && isIsomorphic(root1->right, root2->left));
    }
};

______________________________________________________________

class Solution:
    def findItinerary(self, tickets: List[List[str]]) -> List[str]:
        graph = defaultdict(list)
        
        for src, dst in sorted(tickets, reverse=True):
            graph[src].append(dst)
            
        itinerary = []
        def dfs(airport):
            while graph[airport]:
                dfs(graph[airport].pop())
            itinerary.append(airport)
        
        dfs("JFK")
        
        return itinerary[::-1]