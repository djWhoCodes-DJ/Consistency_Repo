08/08/2023

GFG POTD SOLUTION

class Solution
{
    public:
    int countFractions(int n, int numerator[], int denominator[])
    {   
        map<pair<int,int>,int> mp;
        int ans=0;
        for(int i=0;i<n;i++){
            int d = __gcd(numerator[i],denominator[i]);
            int a=numerator[i]/d;
            int b=denominator[i]/d;
            int diff=b-a;
            if(mp.find({diff,b})!=mp.end()) ans+=mp[{diff,b}];
            mp[{a,b}]++;
        }
        return ans;
    }
};



09/08/2023

GFG POTD SOLUTION

long long int largestPrimeFactor(int n){
        // code here
        vector <int>ans;
        for(int i=2;i<=n;i++)
        {
            while(n%i==0)
            {
                ans.push_back(i);
                n=n/i;
            }
        }
        int maxi=-1;
        for(int i=0;i<ans.size();i++)
        {
            if(ans[i]>maxi)
            {
                maxi=ans[i];
            }
        }
        return maxi;
    }




10/08/2023

GFG POTD SOLUTION

class Solution
{
    //recursive
    static int solve(int i,int j,String s1,String s2,int n,int m){
        if(i>=n || j>=m)return 0;
        
        int ans=0;
        if(s1.charAt(i)==s2.charAt(j)){
            ans=1+solve(i+1,j+1,s1,s2,n,m);
        }else{
            ans=Math.max(solve(i+1,j,s1,s2,n,m),solve(i,j+1,s1,s2,n,m));
        }
        
        return ans;
    }
    //DP
    static int solve_DP(int i,int j,int[][] dp,String s1,String s2,int n,int m){
        if(i>=n || j>=m)return 0;
        if(dp[i][j]!=-1)return dp[i][j];
        int ans=0;
        if(s1.charAt(i)==s2.charAt(j)){
            ans=1+solve_DP(i+1,j+1,dp,s1,s2,n,m);
        }else{
            ans=Math.max(solve_DP(i+1,j,dp,s1,s2,n,m),solve_DP(i,j+1,dp,s1,s2,n,m));
        }
        
        return dp[i][j]=ans;
    }
    //Bottom UP dp
    static int solve_Tab(int n, int m, String s1, String s2){
        int[][] dp=new int[n+1][m+1];
        
        for(int i=n-1;i>=0;i--){
            for(int j=m-1;j>=0;j--){
                int ans=0;
                if(s1.charAt(i)==s2.charAt(j)){
                    ans=1+dp[i+1][j+1];
                }else{
                    ans=Math.max(dp[i+1][j],dp[i][j+1]);
                }
                dp[i][j]=ans;
            }
        }
        return dp[0][0];
    }
    //Space optimazation
    static int solve_Space(int n1, int n2, String a, String b){
        //space complexity is min(n,m);
        int[] currRow = new int[n2 + 1];
        int[] nextRow = new int[n2 + 1];

        for (int i = n1 - 1; i >= 0; i--) {
            for (int j = n2 - 1; j >= 0; j--) {
                int ans = 0;

                if (a.charAt(i) == b.charAt(j))
                    ans = 1 + nextRow[j + 1];
                else
                    ans = Math.max(nextRow[j], currRow[j + 1]);

                currRow[j] = ans;
            }

            System.arraycopy(currRow, 0, nextRow, 0, n2 + 1);
        }

        return nextRow[0];
    }
    static int lcs(int n, int m, String s1, String s2)
    {
        // recursive
        //return solve(0,0,s1,s2,n,m);
        
        //DP
        // int[][] dp=new int[n][m];
        // for(int[] d:dp)Arrays.fill(d,-1);
        // return solve_DP(0,0,dp,s1,s2,n,m);
        
        //Bottom UP
        // return solve_Tab(n,m,s1,s2);
        
        //space optimize
        return solve_Space(n,m,s1,s2);
        
    }
    
}


LEETCODE

class Solution {
public:
    bool search(vector<int>& nums, int target) {
        int l = 0;
        int r = nums.size() - 1;
        
        while(l <= r)
        {
            int mid = l + (r-l) / 2;
            if (nums[mid] == target)
                return true;
			// with duplicates we can have this contdition, just update left & right
            if((nums[l] == nums[mid]) && (nums[r] == nums[mid]))
            {
                l++;
                r--;
            }
			// first half
			// first half is in order
            else if(nums[l] <= nums[mid])
            {
				// target is in first  half
                if((nums[l] <= target) && (nums[mid] > target))
                    r = mid - 1;
                else
                    l = mid + 1;
            }
			// second half
			// second half is order
			// target is in second half
            else
            {
                if((nums[mid] < target) && (nums[r]>= target))
                    l = mid + 1;
                else
                    r = mid - 1;
            }
        }
        return false;
    }
	// for github repository link go to my profile.
};



11/08/2023


GFG POTD

class Solution {
  public:
    long long int dp[1001][1001]; 
    int n;
    long long int helper(int indx, int target, int* coins){
        if (target == 0)
        return 1;
        
        if (indx == n)
        return 0;
        
        if (dp[indx][target] != -1)
        return dp[indx][target];
        
        long long int take = 0, skip = 0;
        if (target >= coins[indx])
        take = helper(indx,target - coins[indx],coins);
        skip = helper(indx+1, target, coins);

        return dp[indx][target] = take + skip;
    }
long long int count(int coins[], int N, int sum) {
    memset(dp,-1,sizeof(dp));
        n = N;
        return helper(0,sum,coins);
}
};




12/08/2023


GFG POTD Solution

class Solution
{
    public:
    //Function to find length of longest increasing subsequence.
    int longestSubsequence(int n, int a[])
    {
      vector<int> piles;
        
        for (int i = 0; i < n; i++) {
            auto it = lower_bound(piles.begin(), piles.end(), a[i]);
            if (it == piles.end()) {
                piles.push_back(a[i]);
            } else {
                *it = a[i];
            }
        }
        
        return piles.size();
    }
};


Leetcode Solution

class Solution:
    def uniquePathsWithObstacles(self, obstacleGrid: List[List[int]]) -> int:
        if not obstacleGrid or not obstacleGrid[0] or obstacleGrid[0][0] == 1:
            return 0
        
        m, n = len(obstacleGrid), len(obstacleGrid[0])
        
        previous = [0] * n
        current = [0] * n
        previous[0] = 1
        
        for i in range(m):
            current[0] = 0 if obstacleGrid[i][0] == 1 else previous[0]
            for j in range(1, n):
                current[j] = 0 if obstacleGrid[i][j] == 1 else current[j-1] + previous[j]
            previous[:] = current
        
        return previous[n-1]



13/08/2023

GFG POTD Solution

class Solution {
    public int nthFibonacci(int n) {

        int modulo = 1000000007;
        int[] dp = new int[n + 1];
        dp[0] = 0;
        dp[1] = 1;

        for (int i = 2; i <= n; i++) {
            dp[i] = (dp[i - 1] + dp[i - 2]) % modulo;
        }

        return dp[n];
    }
}



Leetcode Solution

class Solution:
    def validPartition(self, nums: List[int]) -> bool:
        n = len(nums) 
        if n == 1: 
            return False 
        dp = [True, False, nums[0] == nums[1] if n > 1 else False] 
        for i in range(2, n): 
            current_dp = (nums[i] == nums[i-1] and dp[1]) or \
                         (nums[i] == nums[i-1] == nums[i-2] and dp[0]) or \
                         (nums[i] - nums[i-1] == 1 and nums[i-1] - nums[i-2] == 1 and dp[0])
            dp[0], dp[1], dp[2] = dp[1], dp[2], current_dp 
        return dp[2]




14/08/2023


GFG POTD Solution

class Solution
{
    public int[] singleNumber(int[] nums)
    {
        // Code here
        HashMap<Integer,Integer> map = new HashMap<>();
        List<Integer> ans = new ArrayList<>();
        
        for(int i=0; i<nums.length; i++){
            map.put(nums[i],map.getOrDefault(nums[i],0)+1);
        }
        
        for(Map.Entry<Integer,Integer> entry : map.entrySet()){
            if(entry.getValue()==1){
                ans.add(entry.getKey());
            }
        }
        
        int arr[] = new int[ans.size()];
        Collections.sort(ans);
        int i=0;
        for(int val : ans){
            arr[i] = val;
            i++;
        }
        
        return arr;
    }
}


Leetcode Solution

class Solution:
    def findKthLargest(self, nums, k):
        return sorted(nums, reverse=True)[k-1]



15/08/2023

GFG POTD SOLUTION

class Solution:
    def maxOnes(self, a, n):
        # Your code goes here
        ones=0
        count=0
        max_count=0
        for e in a:
            if e==0:
                if count>=0:
                    count+=1
                else:
                    count=1
            else:
                ones+=1
                count-=1
            max_count=max(max_count,count)
        return ones+max_count



LEETCODE SOLUTION

class Solution:
    def partition(self, head: Optional[ListNode], x: int) -> Optional[ListNode]:
        before, after = ListNode(0), ListNode(0)
        before_curr, after_curr = before, after
        
        while head:
            if head.val < x:
                before_curr.next, before_curr = head, head
            else:
                after_curr.next, after_curr = head, head
            head = head.next
        
        after_curr.next = None
        before_curr.next = after.next
        
        return before.next



16/08/2023


GFG POTD SOLUTION 

class Solution {
    public static int findCatalan(int n) {
        // code here
        long dp[]=new long[n+1];
        dp[0]=dp[1]=1L;
        long mod=1000_000_007L;
        for(int j=2;j<=n;j++){
            long ans=0;
            for (int i = 1; i <=j ; i++) {
                ans=(ans+(dp[i-1]*dp[j-i])%mod)%mod;
            }
            dp[j]=ans;
        }
        return (int)(dp[n]%mod);
    }
}


LEETCODE SOLUTION

class Solution {
    using int2=pair<int, int>; //(nums[i], i)
public:

    vector<int> maxSlidingWindow(vector<int>& nums, int k) {
        int n=nums.size();
        priority_queue<int2> pq;

        vector<int> ans(n-k+1);
        for (int i=0; i<k; i++)
            pq.push({nums[i], i});
        
        ans[0]=pq.top().first;
        for(int i=k; i<n; i++){
            while(!pq.empty() && pq.top().second<=(i-k))
                pq.pop(); //Pop up element not in the window
            pq.push({nums[i], i});
            ans[i-k+1]=pq.top().first;//Max element for this window
        }
        return ans;
    }
};


_________________________________________________________

GFG POTD

class Solution:
    def searchWord(self, grid, word):
        n, m, k = len(grid), len(grid[0]), len(word)
        
        D = [ [-1,-1], [-1, 0], [-1,1],    
              [ 0,-1],          [ 0,1],     
              [ 1,-1], [ 1, 0], [ 1,1]  ]
        def getNextIJ(i, j, direction):
            return i+D[direction][0], j+D[direction][1]
            
            
        def dfs(direction, curLen, curI, curJ):
            if curLen == k:
                return True
            if not (0<=curI<n and 0<=curJ<m):
                return False
            if word[curLen] != grid[curI][curJ]:
                return False
            nextI, nextJ = getNextIJ(curI, curJ, direction)
            return dfs(direction, curLen+1, nextI, nextJ)
        def match(i, j):
            for dire in range(8):
                nextI, nextJ = getNextIJ(i, j, dire)
                if dfs(dire, 1, nextI, nextJ):
                    return True
        ans = []
        for i in range(n):
            for j in range(m):
                if grid[i][j] == word[0] and match(i, j):
                    ans.append([i, j])
        return ans

_________________________________________________________


class Solution:
    def reorganizeString(self, s: str) -> str:
        freq_map = {}
        for char in s:
            freq_map[char] = freq_map.get(char, 0) + 1
            
        max_heap = [(-freq, char) for char, freq in freq_map.items()]
        heapq.heapify(max_heap)
        
        res = []
        
        while len(max_heap) >= 2:
            freq1, char1 = heapq.heappop(max_heap)
            freq2, char2 = heapq.heappop(max_heap)
            
            res.extend([char1, char2])
            
            if freq1 + 1 < 0:
                heapq.heappush(max_heap, (freq1 + 1, char1))
            if freq2 + 1 < 0:
                heapq.heappush(max_heap, (freq2 + 1, char2))
                
        if max_heap:
            freq, char = heapq.heappop(max_heap)
            if -freq > 1:
                return ""
            res.append(char)
            
        return "".join(res)



_________________________________________________________

class Solution:
    def fullJustify(self, words: List[str], maxWidth: int) -> List[str]:
        res, line, width = [], [], 0

        for w in words:
            if width + len(w) + len(line) > maxWidth:
                for i in range(maxWidth - width): line[i % (len(line) - 1 or 1)] += ' '
                res, line, width = res + [''.join(line)], [], 0
            line += [w]
            width += len(w)

        return res + [' '.join(line).ljust(maxWidth)]



_________________________________________________________

string multiplyStrings(string s1, string s2) {
   
   bool neg = false;
   if(s1[0]=='-'){
       neg = !neg;
       s1 = s1.substr(1);
   }
   if(s2[0]=='-'){
       neg = !neg;
       s2 = s2.substr(1);
   }
   
   int cnt1, cnt2;
   for(cnt1=0; s1[cnt1]=='0'; cnt1++);
   for(cnt2=0; s2[cnt2]=='0'; cnt2++);
   s1 = s1.substr(cnt1);
   s2 = s2.substr(cnt2);
   
   if(s1.empty() || s2.empty()) return "0"; 
   
   string ans="";
   int len1=s1.length(), len2=s2.length();
   
   for(int i = len1-1; i >= 0; i--){
       
       int ansidx=ans.length()-len1+i, k=len2-1, carry=0;
       
       for(;ansidx>=0 && k>=0; k--, ansidx--){
           int n1 = s1[i]-'0';
           int n2 = s2[k]-'0';
           int n3 = ans[ansidx]-'0';
           int n4 = n1*n2 + n3 + carry;
           ans[ansidx] = '0' + n4%10;
           carry = n4/10;
       }
       for(; k >= 0; k--){
          int n1 = s1[i]-'0';
          int n2 = s2[k]-'0';
          int n3 = n1*n2 + carry;
          ans = ((char)('0' + n3%10)) + ans;
          carry = n3/10;
       }
       if(carry) ans = ((char)('0'+carry)) + ans;
   }
   
   if(neg) return ('-'+ans);
   return ans;
   
}